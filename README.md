# easerpc
crossplatform interprocess rpc
====
* Linux & Windows supported
* Makefile generated by cmake
* based on zeromq

sequence of rpc events 
====
  -- From Wikipedia (Remote procedure call)

* The client calls the client stub. The call is a local procedure call, with parameters pushed on to the stack in the normal way.
* The client stub packs the parameters into a message and makes a system call to send the message. Packing the parameters is called marshalling.
* The client's local operating system sends the message from the client machine to the server machine.
* The local operating system on the server machine passes the incoming packets to the server stub.
* The server stub unpacks the parameters from the message. Unpacking the parameters is called unmarshalling.
* Finally, the server stub calls the server procedure. The reply traces the same steps in the reverse direction.

sample (on Windows)
====
* start up rpc node 3
```bash
# callee.exe 3

```

* start rpc client, sending requests
```bash
# C:\Python35\python.exe
> import ctypes; lib = ctypes.CDLL('easerpc.dll')
> resp = ctypes.create_string_buffer(1024)
> lib.rpc_request(3, b'add', b'{"param1":3, "param2":4}', ctypes.byref(resp), ctypes.sizeof(resp), 500, 500)
```

sample 2 (on Windows)
====
* start up zmq worker
```bash
# C:\Python35\python.exe
# import ctypes; lib = ctypes.CDLL('easerpc.dll')
# lib.test_zmq_worker(b'127.0.0.1', 9091, 1000)
```

* start up zmq broker
```bash
# C:\Python35\python.exe
# import ctypes; lib = ctypes.CDLL('easerpc.dll')
# lib.test_zmq_broker(b'127.0.0.1', 9093, b'127.0.0.1', 9091)
```

* start up zmq worker
```bash
# C:\Python35\python.exe
# import ctypes; lib = ctypes.CDLL('easerpc.dll')
# lib.test_zmq_client(b'127.0.0.1', 9093, 1)
```

NOTE
====
* ipc (inter-process communication) is not supported by zmq on Windows, so TCP port is used here :(
* inproc & TCP are supported by zmq on both Linux & Windows

TODO
====
* a registry center is in need to parse "rpc node id" to "TCP port"
* test on Debian